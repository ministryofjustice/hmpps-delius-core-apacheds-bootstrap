---
# tasks file for hmpps-delius-core-apacheds-bootstrap

- name: Set facts
  set_fact:
    ldap_connection: '-H {{ ldap_protocol }}://localhost:{{ ldap_port }} -D {{ bind_user }} -w ${bind_password}'
    partition_context_entry: 'dn:{{ base_root }}\ndc:{{ partition_id }}\nobjectclass:domain\nobjectclass:top'
    consumer_id: 'consumer-{{ inventory_hostname }}'
    base_users: 'cn=Users,{{ base_root }}'

- name: Set more facts
  set_fact:
    base_service_users: 'cn=EISUsers,{{ base_users }}'
    base_roles: 'cn=ndRoleCatalogue,{{ base_users }}'
    base_rolegroups: 'cn=ndRoleGroups,{{ base_users }}'

- name: Block inbound access on ldap_port until bootstrap is finished
  iptables:
    chain: INPUT
    protocol: tcp
    source: '!127.0.0.1'
    destination_port: '{{ ldap_port }}'
    jump: REJECT
    state: present
  become: yes

- when: is_consumer
  block:
  - name: Wait for provider/master node (initial delay)
    wait_for: timeout=5
    delegate_to: localhost
  - name: Wait for provider/master node
    shell: 'ldapwhoami -H {{ ldap_protocol }}://{{ provider_host }}:{{ ldap_port }} -D {{ bind_user }} -w ${bind_password}'
    retries: 360
    delay: 10
    register: result
    until: result.rc == 0
    environment:
      bind_password: '{{ bind_password }}'

- name: Set JVM memory args
  replace:
    path: '{{ apacheds_lib_directory }}/conf/wrapper.conf'
    regexp: '{{ item.regexp }}'
    replace: '{{ item.replace }}'
  with_items:
    - { regexp: '^#wrapper.java.initmemory=.*$', replace: 'wrapper.java.initmemory={{ jvm_mem_args }}' }
    - { regexp: '^#wrapper.java.maxmemory=.*$', replace: 'wrapper.java.maxmemory={{ jvm_mem_args }}' }

- name: Start service apacheds, on boot
  service:
    name: "{{ apacheds_version }}"
    enabled: yes

- name: Restart apacheds
  include: restart-apacheds.yml

- name: Create workspace if it doesn't exist
  become: yes
  become_user: apacheds
  file:
    path: '{{ workspace }}'
    state: directory
    mode: 0755

- name: Copy LDIFs
  become: yes
  become_user: apacheds
  template:
    src: '{{ item.file }}.j2'
    dest: '{{ workspace }}/{{ item.file }}'
    mode: 0644
  with_items:
    - { file: partition.ldif }
    - { file: context.ldif }
    - { file: schema.ldif }
    - { file: service-users.ldif }
    - { file: modify-schema.ldif }
    - { file: modify-admin.ldif }
    - { file: repl-provider.ldif }
    - { file: repl-consumer.ldif }
    - { file: interceptor.ldif }

- name: Copy config
  become: yes
  become_user: apacheds
  template:
    src: '{{ item.file }}.j2'
    dest: '{{ apacheds_install_directory }}/conf/{{ item.file }}'
    mode: 0644
  with_items:
    - { file: log4j.properties }

- name: Copy custom lib jar
  become: yes
  become_user: apacheds
  copy:
    src: 'files/NDelius-apacheds-lib-3.0.jar'
    dest: '{{ apacheds_lib_directory }}/lib/NDelius-apacheds-lib-3.0.jar'
    mode: 0644

- name: Update admin password
  become: yes
  become_user: apacheds
  shell: 'ldapmodify {{ ldap_connection }} -f {{ workspace }}/modify-admin.ldif'
  environment:
    bind_password: 'secret'

- name: Restart apacheds
  include: restart-apacheds.yml

- name: Download role catalogues
  when: s3_dependencies_bucket is defined
  become: yes
  become_user: apacheds
  aws_s3:
    bucket: '{{ s3_dependencies_bucket }}'
    object: '/dependencies/delius-core/NDelius-{{ ndelius_version }}/scripts/User Data Store/{{ item.file }}'
    dest: '{{ workspace }}/{{ item.file }}'
    mode: get
  with_items:
    - { file: nd_role_catalogue.ldif }
    - { file: nd_role_groups.ldif }

- name: Copy local role catalogues
  when: s3_dependencies_bucket is not defined
  copy:
    src: 's3/dependencies/delius-core/NDelius-{{ ndelius_version }}/scripts/User Data Store/{{ item.file }}'
    dest: '{{ workspace }}/{{ item.file }}'
    owner: apacheds
    group: apacheds
    mode: 0644
  with_items:
    - { file: nd_role_catalogue.ldif }
    - { file: nd_role_groups.ldif }

- name: Replace context in LDIFs
  become: yes
  become_user: apacheds
  replace:
    path: '{{ workspace }}/{{ item.file }}'
    regexp: 'dc=pcms,dc=internal'
    replace: '{{ base_root }}'
  with_items:
    - { file: nd_role_catalogue.ldif }
    - { file: nd_role_groups.ldif }

- name: Create partition & import schema
  become: yes
  become_user: apacheds
  shell: 'ldapadd {{ ldap_connection }} -f {{ workspace }}/{{ item.file }}'
  environment:
    bind_password: '{{ bind_password }}'
  with_items:
    - { file: partition.ldif }
    - { file: schema.ldif }
    - { file: interceptor.ldif }

- name: Replace Base64-encoded creatorsName attribute in schema with plaintext value
  become: yes
  become_user: apacheds
  replace:
    path: '~/default/partitions/schema/ou=schema/cn=subschemasubentry.ldif'
    regexp: 'creatorsName:: [\w\W\n]+?(.+?):'
    replace: 'creatorsName: {{ bind_user }}\n\1:'

- name: Modify existing schema objects
  become: yes
  become_user: apacheds
  shell: 'ldapmodify {{ ldap_connection }} -f {{ workspace }}/modify-schema.ldif'
  environment:
    bind_password: '{{ bind_password }}'

- name: Restart apacheds
  include: restart-apacheds.yml

- name: Import roles, groups and service users
  become: yes
  become_user: apacheds
  shell: 'ldapadd {{ ldap_connection }} -f {{ workspace }}/{{ item.file }}'
  environment:
    bind_password: '{{ bind_password }}'
  with_items:
    - { file: context.ldif }
    - { file: nd_role_catalogue.ldif }
    - { file: nd_role_groups.ldif }
    - { file: service-users.ldif }

- name: Restart apacheds
  include: restart-apacheds.yml

- name: Get the name of the latest backup
  when: import_users_ldif == 'LATEST'
  become: yes
  become_user: apacheds
  shell: "aws s3 ls s3://{{ s3_backups_bucket }}/ldap/ --recursive | sort | tail -n 1 | awk '{print $4}'"
  register: latest_backup

- name: Store the name of the latest backup
  when: import_users_ldif == 'LATEST'
  set_fact:
    import_users_ldif: '{{ latest_backup.stdout }}'

- name: Create LDIF directory
  when: import_users_ldif is defined and not is_consumer
  become: yes
  become_user: apacheds
  shell: 'mkdir -p $(dirname {{ workspace }}/{{ import_users_ldif }})'

- name: Download LDIF file for import
  when: s3_backups_bucket is defined and import_users_ldif is defined and not is_consumer
  become: yes
  become_user: apacheds
  aws_s3:
    bucket: '{{ s3_backups_bucket }}'
    object: '{{ import_users_ldif }}'
    dest: '{{ workspace }}/{{ import_users_ldif }}'
    mode: get

- name: Copy local LDIF file for import
  when: s3_backups_bucket is not defined and import_users_ldif is defined and not is_consumer
  copy:
    src: 's3/{{ import_users_ldif }}'
    dest: '{{ workspace }}/{{ import_users_ldif }}'
    owner: apacheds
    group: apacheds
    mode: 0644

- name: Remove OID-specific stuff from LDIF and sort hierarchically
  when: import_users_ldif is defined and not is_consumer and sanitize_oid_ldif
  block:
    - copy:
        src: 'ldif-sort.jar'
        dest: '{{ workspace }}/ldif-sort.jar'
        mode: 0644
    - shell: 'java -jar {{ workspace }}/ldif-sort.jar {{ workspace }}/{{ import_users_ldif }} > {{ workspace }}/{{ import_users_ldif }}-sorted'
    - shell: 'mv {{ workspace }}/{{ import_users_ldif }}-sorted {{ workspace }}/{{ import_users_ldif }}'
    - replace:
        path: '{{ workspace }}/{{ import_users_ldif }}'
        regexp: '{{ item.regexp }}'
        replace: '{{ item.replace }}'
      with_items:
        - { regexp: '(?i)dn: cn=users[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*eisusers[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*cn=SPG,[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*cn=ALF,[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*cn=c\d{2},[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*cn=ndrolecatalogue,[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*cn=ndrolegroups,[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*cn=orcladmin,[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)dn:.*cn=public,[\w\W]+?\n\n', replace: '' }
        - { regexp: '(?i)^orclActiveStartDate: ', replace: 'startDate: ' }
        - { regexp: '(?i)^orclActiveEndDate: ', replace: 'endDate: ' }
        - { regexp: '(?i)^objectclass: orcl.+?\n', replace: '' }
        - { regexp: '(?i)^authpassword.+?\n', replace: '' }
        - { regexp: '(?i)^orcl.+?\n', replace: '' }
        - { regexp: '(?i)^krbprincipalname.+?\n', replace: '' }

- name: Import users
  when: import_users_ldif is defined and not is_consumer
  become: yes
  become_user: apacheds
  shell: 'ldapadd {{ ldap_connection }} -c -f {{ workspace }}/{{ import_users_ldif }}'
  register: import_users_from_backup
  failed_when: import_users_from_backup.rc not in [0,33,68]
  # Allowed return codes:
  # 0=SUCCESS
  # 33=ALIAS_PROBLEM (invalid role association which should be ignored)
  # 68=ENTRY_EXISTS (duplicate entries should be ignored)
  environment:
    bind_password: '{{ bind_password }}'

- name: Pull data from provider/master node
  when: is_consumer
  become: yes
  become_user: apacheds
  shell: >
    ldapsearch -L
    -H {{ ldap_protocol }}://{{ provider_host }}:{{ ldap_port }}
    -D {{ bind_user }} -w ${bind_password}
    -b {{ base_root }} "(objectclass=*)" > {{ workspace }}/master-data.ldif
  environment:
    bind_password: '{{ bind_password }}'

- name: Import data from provider/master node
  when: is_consumer
  become: yes
  become_user: apacheds
  shell: 'ldapadd {{ ldap_connection }} -c -f {{ workspace }}/master-data.ldif'
  register: import_users_from_master
  failed_when: import_users_from_master.rc not in [0,33,68]
  # Allowed return codes:
  # 0=SUCCESS
  # 33=ALIAS_PROBLEM (invalid role association which should be ignored)
  # 68=ENTRY_EXISTS (duplicate entries should be ignored)
  environment:
    bind_password: '{{ bind_password }}'

- name: Set host as a provider (master) node
  when: not is_consumer
  become: yes
  become_user: apacheds
  shell: 'ldapmodify {{ ldap_connection }} -f {{ workspace }}/repl-provider.ldif'
  environment:
    bind_password: '{{ bind_password }}'

- name: Set host as a consumer (slave) node
  when: is_consumer
  become: yes
  become_user: apacheds
  shell: 'ldapmodify {{ ldap_connection }} -f {{ workspace }}/repl-consumer.ldif'
  environment:
    bind_password: '{{ bind_password }}'

- name: Restart apacheds
  include: restart-apacheds.yml

- name: Upload backup script
  when: not is_consumer
  template:
    src: 'backup_ldap.sh.j2'
    dest: '/usr/bin/backup_ldap'
    mode: u+x

- name: Create a cron job to perform daily backups
  when: not is_consumer
  cron:
    name: Backup to S3
    job: 'backup_ldap'
    special_time: daily

- name: Re-enable inbound access on ldap_port
  iptables:
    chain: INPUT
    protocol: tcp
    source: '!127.0.0.1'
    destination_port: '{{ ldap_port }}'
    jump: REJECT
    state: absent
  become: yes
